---
title:  "C++ 기초 정리 (+ 연산자)"

categories:
  - Cpp
tags:
  - [Cpp, C++, operator]

toc: true
toc_sticky: true
 
date: 2025-04-24
last_modified_at: 2025-04-24
---

<br>

# 크기

용량의 최소단위 : bit  
1bit는 0, 1 둘중에 하나의 값을 저장할 수 있는 공간이다.  
|1byte|8bit|
|1kbyte|1024byte|
|1mbyte|1024kbyte|
|1gbyte|1024mbyte|
|1tbyte|1024gbyte|

크기 : byte단위  
문자 표현시 한글, 한자는 2바이트를 차지한다.  
문자는 값을 저장하고 값에 해당하는 문자를 ASCII 코드에서 찾아서 표현한다.  



# 타입

signed : +, - 부호가 있다.  
unsigned : 부호가 없다.(+만 있다.)  
기본은 signed 이다.  

- 표현범위를 벗어나면 동작되는 방식
  - 최대값 이상 : 최소값으로 전환  
  - 최소값 이하 : 최대값으로 전환  

INT_MAX : int로 표현할 수 있는 최대값  
INT64_MAX : __int64로 표현할 수 있는 최대값  

|타입|크기|종류|표현범위|
|----|---|----|------|
|bool|1|참/거짓|false(0) - true(1)|
|char|1|문자|-128 ~ 127|
|short|2|정수|-32768 ~ 32767|
|int|4|정수|-2147483648 ~ 2147483647|
|__int64|8|정수||
|float|4|실수||
|double|8|실수||



# 사칙연산 및 연산 우선순위

사칙연산자 : +, -, *, /, %(나머지 연산)  
*, /, % 연산이 먼저된다.  
나머지 연산은 A를 B로 나눈 나머지 값을 구해준다.  
`10 % 3 = 1`  

나머지 연산은 정수 대 정수 연산을 지원한다.  
`Number = 3.14f % 322.33f;` -> 에러  

나눗셈 연산을 할 때 결과값을 실수형태로 얻고 싶다면  
나눗셈을 수행하는 2개의 값중 1개라도 실수여야 한다.  
A / B 를 수행할 때 둘 다 정수라면 결과도 정수로 나오고 소수점이 짤린다.  

%d : 정수값을 받아서 문자열로 변경.  
%f : 실수값을 받아서 문자열로 변경.  
%c : 문자 1개를 받아서 문자열로 변경.  
%s : 문자열을 받아서 문자열로 변경.  

%는 특수한 행동을 하는 문자이므로 문자열 내에서 %를 쓰고 싶다면 %% 이렇게 두 번 쓰면 나타난다.  
`printf("10 %% 3 = %d\n", Number);`

```
//Number = 10 / 0;    -> 에러  
Number = 0 / 10;    // -> 에러 안남

int	Number11 = 10, Number12 = 0;
//Number = Number11 / Number12; //    -> 에러
```

- 사칙 연산자가 관계연산자보다 우선순위가 높다.  
```
Result = 10 + 7 > 20 + 2;
printf("10 + 7 > 20 + 2 = %d\n", Result); // -> 결과는 false
```


# 논리 연산자

논리연산자 : 참/거짓 대 참/거짓을 연산하여 결과로 참/거짓이 나오는 연산자이다.  
AND(&&), OR(||), NOT(!)  
AND : 둘다 참일 경우만 참이고 아니면 거짓이다.  
OR : 둘중 하나라도 참이면 참이고 아니면 거짓이다.  

|A|B|AND|OR|
|:-:|:-:|:---:|:---:|
|0|0|0|0|
|1|0|0|1|
|0|1|0|1|
|1|1|1|1|

NOT : 반대로 나온다.  

|A|NOT|
|:-:|:---:|
|0|1|
|1|0|



# 진수

- 2진수 : 0, 1 둘중 하나로 표현.  
- 10진수 : 0 ~ 9 사이의 숫자로 표현.  
- 16진수 : 0 ~ 15 사이의 숫자로 표현.  
  10 ~ 15는 두자리를 차지하기 때문에 a ~ f 로 표현.

> 👍 213을 2진수, 16진수로 변환해보자.


## 2진수

```
213 / 2 = 106 -- 1
106 / 2 = 53 --- 0
53 / 2 = 26 ---- 1
26 / 2 = 13 ---- 0
13 / 2 = 6 ----- 1
6 / 2 = 3 ------ 0
3 / 2 = 1 ------ 1
```

더이상 2로 나눌 수 없다면 마지막 몫부터 거꾸로 읽는다.  
`213 = 11010101`

|1|1|0|1|0|1|0|1|
|:---:|:--:|:--:|:--:|:-:|:-:|:-:|:-:|
|128|64|32|16|8|4|2|1|

`128 + 64 + 16 + 4 + 1 = 213`

2진수는 앞에 0b를 붙여서 표현한다.


## 16진수

16진수 1자리는 2진수 4자리를 차지한다.
|1|1|0|1|/|0|1|0|1|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|8|4|2|1|/|8|4|2|1|

`8 + 4 + 1 / 4 + 1`  
`13 / 5`  
`d / 5`  (-> d : 10, 11, 12, 13 을 a, b, c, d 순으로 적용하면 d가 됨됨)
`0xd5`  

16진수는 앞에 0x를 붙여서 표현한다.

```
// 다시 2진수로 풀어헤쳐보면,
5 / 2 = 2 -- 1
2 / 2 = 1 -- 0
// => 0101 (자리 갯수가 부족하면 앞에 0 붙인다)

13 / 2 = 6 - 1
6 / 2 = 3 -- 0
3 / 2 = 1 -- 1

// 11010101
```



# 비트 연산자

비트단위 논리연산자 : AND(&), OR(|), NOT(~), XOR(^)  
A와 B를 연산하게 되면 먼저 A와 B를 2진수로 변환하고  
각 자리별로 논리연산을 수행한다.  

|A|B|XOR|
|:-:|:-:|:---:|
|0|0|0|
|1|0|1|
|0|1|1|
|1|1|0|

```
// &
213 : 11010101
479 : 111011111
479 & 213 = 213
 111011111
&011010101
 011010101

// |
479 | 213 = 479
 111011111
|011010101
 111011111

// ^
479 ^ 213 = 266
 111011111
^011010101
 100001010
 256 + 2 + 8 = 266

// ~
~213 = -214

~ 00000000 00000000 00000000 11010101
  11111111 11111111 11111111 00101010
```

## 비트 연산 예시

```
// 0x00000001와 0x1은 같다.
// 0x00000001 :     1 -> 2진수로 표현하면 1
// 0x00000002 :    10 -> 2진수로 표현하면 10
// 0x00000004 :   100
// 0x00000008 :  1000
// 0x00000010 : 10000
const int	Attack = 0x00000001;
const int	Defense = 0x00000002;
const int	HPBuf = 0x00000004;
const int	MPBuf = 0x00000008;
const int	Critical = 0x00000010;

int	Buf = 0;

// Buf = 0 | 1 = 1
Buf = Buf | Attack;

// Buf = 001 | 100 = 101
Buf = Buf | HPBuf;

// Buf = 00101 | 10000 = 10101
Buf = Buf | Critical;

// Buf = 10101 ^ 00100 = 10001
Buf = Buf ^ HPBuf;              // 버프 제거

// Buf = 10001 ^ 00100 = 10101
Buf = Buf ^ HPBuf;              // 버프 재생성

printf("Attack : %d\n", Buf & Attack);
printf("Defense : %d\n", Buf & Defense);
printf("HPBuf : %d\n", Buf & HPBuf);
printf("MPBuf : %d\n", Buf & MPBuf);
printf("Critical : %d\n", Buf & Critical);
```



# 쉬프트 연산자

쉬프트연산자 : <<, >> 2가지가 있다.  

10 을 2진수로 변환하면 -> 1010  

10 << 2 = 101000 = 40	-> 0을 뒤에 2개 붙임
10 << 3 = 1010000 = 80	-> 0을 뒤에 3개 붙임

<b>-> 결과적으로 2의 n승만큼 곱해지는 것</b>

80 >> 2 = 10100 = 20	-> 뒤에 2비트 삭제
80 >> 3 = 1010 = 10		-> 뒤에 3비트 삭제

<b>-> 결과적으로 2의 n승만큼 나눠지는 것</b>